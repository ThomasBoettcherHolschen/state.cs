/* State v5 finite state machine library
 * http://www.steelbreeze.net/state.cs
 * Copyright (c) 2014-5 Steelbreeze Limited
 * Licensed under MIT and GPL v3 licences
 */
using System;
using System.Collections.Generic;

namespace Steelbreeze.Behavior.StateMachines {
	/// <summary>
	/// A simple abstract class to extend as a base for a state machine instances.
	/// </summary>
	/// <typeparam name="TInstance">The type of the derived IActiveStateConfiguration class.</typeparam>
	/// <remarks>
	/// By passing the type of the derived class into this base, it allows the callbacks generated by the state machine to pass the fully typed derived class.
	/// Note that properties and methods have been explicitly implemented to hide the members from use other than via the IContext interface.
	/// Should you need persistence, or other such behaviour relating to the instance class, create a custom class implementing IActiveStateConfiguration.
	/// </remarks>
	public abstract class StateMachineInstanceBase<TInstance> : IActiveStateConfiguration<TInstance> where TInstance : class, IActiveStateConfiguration<TInstance> {
		// use a dictionary to store the last known state of a Region
		private readonly Dictionary<Region<TInstance>, State<TInstance>> active = new Dictionary<Region<TInstance>, State<TInstance>> ();

		/// <summary>
		/// Indicates that the state machine instance has been terminated.
		/// </summary>
		/// <remarks>A state machine is only deemed terminated if a transitions target is a Terminate PseudoState.</remarks>
		public Boolean IsTerminated { get; set; }

		// sets and gets the current state of a specified Region
		State<TInstance> IActiveStateConfiguration<TInstance>.this[ Region<TInstance> region ] {
			set {
				this.active[ region ] = value;
			}

			get {
				var value = default (State<TInstance>);

				this.active.TryGetValue (region, out value);

				return value;
			}
		}
	}
}